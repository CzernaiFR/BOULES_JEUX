{
  "hash": "d8e654ecbc5e2bd92108681c481dd053",
  "result": {
    "engine": "knitr",
    "markdown": "---\nauthor: Roger MARTIN\ndate: last-modified\ndate-format: \"dddd D MMMM YYYY\"\n---\n\n\n\n\n\n# EuroDreams\n\n## Récupérer l'historique des tirages\n\nLa FDJ met à disposition l'historique des tirages [*Eurodreams*](https://www.fdj.fr/jeux-de-tirage/eurodreams/historique). Et pour analyser des données, il faut des ... données.\n\nIl faut donc commencer par charger les `library()` nécessaires.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse, quietly = TRUE, warn.conflicts = FALSE)\nlibrary(utils)\nlibrary(zip)\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# noms des colonnes à garder\nnoms <- c(\"jour_de_tirage\", \"date_de_tirage\",\n          \"boules_gagnantes_en_ordre_croissant\",\n          \"numero_dream\")\n\ndonnees <- readr::read_csv2(\"donnees/eurodreams_202311.csv\", \n                       col_select = noms)\n# affiche les 6 premières lignes\n#   du tableau `donnees`\nhead(donnees)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 4\n  jour_de_tirage date_de_tirage boules_gagnantes_en_ordre_croissant numero_dream\n  <chr>          <chr>          <chr>                                      <dbl>\n1 JEUDI          29/05/2025     -16-18-19-21-22-32-                            5\n2 LUNDI          26/05/2025     -2-17-18-21-25-35-                             2\n3 JEUDI          22/05/2025     -1-5-15-26-31-36-                              4\n4 LUNDI          19/05/2025     -8-15-26-32-35-38-                             2\n5 JEUDI          15/05/2025     -11-15-24-26-32-37-                            2\n6 LUNDI          12/05/2025     -4-15-19-21-25-37-                             2\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# rendre les noms plus accessibles\n\n# le vecteur `noms` contient les noms par paires\n#   \"nonveau nom\" = \"ancien nom\"\nnoms <- c(jt = \"jour_de_tirage\",\n          dt = \"date_de_tirage\",\n          bg = \"boules_gagnantes_en_ordre_croissant\",\n          nd = \"numero_dream\")\ndonnees <- rename(donnees, all_of(noms))\n\n# remplace LUNDI par L et JEUDI par J\ndonnees$jt <- recode(donnees$jt, \"LUNDI\" = \"L\", \"JEUDI\" = \"J\")\nhead(donnees)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 4\n  jt    dt         bg                     nd\n  <chr> <chr>      <chr>               <dbl>\n1 J     29/05/2025 -16-18-19-21-22-32-     5\n2 L     26/05/2025 -2-17-18-21-25-35-      2\n3 J     22/05/2025 -1-5-15-26-31-36-       4\n4 L     19/05/2025 -8-15-26-32-35-38-      2\n5 J     15/05/2025 -11-15-24-26-32-37-     2\n6 L     12/05/2025 -4-15-19-21-25-37-      2\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# extrait tous les tirages de la \n#   colonne `donnees$bg`\nb <- str_extract_all(donnees$bg, \"\\\\d+\")\n\n# mettre b à plat\nb1 <- unlist(b)\n\n# transforme en nombre\nb1 <- as.integer(b1)\n\n# tranforme la `list()` en `matrix()`\nb2 <- matrix(data = b1, ncol = 6, byrow = TRUE)\n\nhead(b2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4] [,5] [,6]\n[1,]   16   18   19   21   22   32\n[2,]    2   17   18   21   25   35\n[3,]    1    5   15   26   31   36\n[4,]    8   15   26   32   35   38\n[5,]   11   15   24   26   32   37\n[6,]    4   15   19   21   25   37\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# affecter les colonnes de la matrice au\n#   jeu de données `donnees`\n\ndonnees <- donnees %>% \n  mutate(n1 = b2[,1], .after = bg) %>% \n  mutate(n2 = b2[,2], .after = n1) %>%\n  mutate(n3 = b2[,3], .after = n2) %>% \n  mutate(n4 = b2[,4], .after = n3) %>% \n  mutate(n5 = b2[,5], .after = n4) %>% \n  mutate(n6 = b2[,6], .after = n5) %>% \n  mutate(bg = NULL) \n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# transforme les jours de tirage `jt` en facteur\ndonnees$jt <- donnees$jt %>%  \n  factor(levels = c(\"L\", \"J\"))\n\n# transforme les dates en dates compréhensibles \n#   par R\ndonnees$dt <- dmy(donnees$dt)\n\n# R sait que `dt` est une colonnes de dates\n#   ranger les tirages en ordre déscendant\n#   ils sont ascendants d'origine\ndonnees <- arrange(donnees, dt)\nhead(donnees)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 9\n  jt    dt            n1    n2    n3    n4    n5    n6    nd\n  <fct> <date>     <int> <int> <int> <int> <int> <int> <dbl>\n1 L     2023-11-06    10    13    14    25    30    35     5\n2 J     2023-11-09    14    16    19    31    32    37     2\n3 L     2023-11-13     1     6    25    26    33    39     2\n4 J     2023-11-16     5    11    13    18    25    27     5\n5 L     2023-11-20     6    13    18    25    26    32     3\n6 J     2023-11-23     4    15    22    23    28    35     4\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(donnees)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n jt           dt                   n1               n2              n3       \n L:82   Min.   :2023-11-06   Min.   : 1.000   Min.   : 2.00   Min.   : 3.00  \n J:82   1st Qu.:2024-03-27   1st Qu.: 2.000   1st Qu.: 8.00   1st Qu.:14.00  \n        Median :2024-08-17   Median : 4.000   Median :12.00   Median :18.00  \n        Mean   :2024-08-17   Mean   : 5.768   Mean   :12.04   Mean   :17.93  \n        3rd Qu.:2025-01-06   3rd Qu.: 8.000   3rd Qu.:16.00   3rd Qu.:22.00  \n        Max.   :2025-05-29   Max.   :18.000   Max.   :27.00   Max.   :33.00  \n       n4              n5              n6              nd       \n Min.   : 9.00   Min.   :10.00   Min.   :16.00   Min.   :1.000  \n 1st Qu.:20.00   1st Qu.:25.00   1st Qu.:32.00   1st Qu.:2.000  \n Median :23.00   Median :30.00   Median :37.00   Median :3.000  \n Mean   :23.63   Mean   :29.46   Mean   :34.95   Mean   :2.915  \n 3rd Qu.:28.00   3rd Qu.:33.25   3rd Qu.:39.00   3rd Qu.:4.000  \n Max.   :37.00   Max.   :38.00   Max.   :40.00   Max.   :5.000  \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Nettoyage\nrm(b, b1, b2, noms, url)\n```\n:::\n\n\n\n\n\n## Stats de base\n\nLes 3 fonctions ci-dessous permettent de récupérer des éléments dans le jeu de données `donnees`.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrecup_n1_n6 <-              # récupère les 6 numéros\n  function(x)               #   du tirage numéro x\n    donnees %>% \n    slice(x) %>% \n    select(n1:n6) %>% \n    as_vector()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nrecup_nd <-                 # récupère le numéro dream\n  function(x)               #   du tirage numéro x\n    donnees %>% \n    slice(x) %>% \n    select(nd) %>% \n    as_vector()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nrecup_jt <-                 # récupère le jour du tirage\n  function(x)               #   du tirage numéro x\n    donnees %>% \n    slice(x) %>% \n    select(jt) %>% \n    as_vector()\n```\n:::\n\n\n\n\n\nPour gérer les statistiques, on va utiliser des `tibble()` :\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnums <- tibble(\n  # Première colonne pour la liste des numéros\n  nu = c(1:40),\n  # Pour les sorties de tous les numéros\n  so = rep.int(0, 40),\n  # Pour les sorties de tous les numéros LUNDI\n  so_L = rep.int(0, 40),\n  # Pour les sorties de tous les numéros JEUDI\n  so_J = rep.int(0, 40),\n  \n  # Pour les écarts de tous les numéros\n  ec = rep.int(0, 40),\n  # Pour les écarts de tous les numéros LUNDI\n  ec_L = rep.int(0, 40),\n  # Pour les écarts de tous les numéros JEUDI\n  ec_J = rep.int(0, 40)\n)\n```\n:::\n\n\n\n\n\net pareil pour les numéros **dream** :\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndreams <- tibble(\n  # Première colonne pour la liste des nums dream\n  nu = c(1:5),\n  # Pour les sorties de tous les nums dream\n  so = rep.int(0, 5),\n  # Pour les sorties des nums dream LUNDI\n  so_L = rep.int(0, 5),\n  # Pour les sorties des nums dream JEUDI\n  so_J = rep.int(0, 5),\n  \n  # Pour les écarts de tous les nums dream\n  ec = rep.int(0, 5),\n  # Pour les écarts des nums dream LUNDI\n  ec_L = rep.int(0, 5),\n  # Pour les écarts des nums dream JEUDI\n  ec_J = rep.int(0, 5)\n)\n```\n:::\n\n\n\n\n\n## Premiers calculs\n\nOn va prendre le tiers pour les données initiales.\n\nRemplir les colonnes des `nums` et `dream`. Et commencer à créer des données. Récupérer le nombre de tirages et en retenir $\\frac{1}{3}$.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# nombre de lignes pour commencer\nnbre_lignes <- round(nrow(donnees) / 3)\nnbre_lignes\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 55\n```\n\n\n:::\n:::\n\n\n\n\n\nPuis, itérer[@noauthor_iteration_2025] sur les `nbre_lignes` premières lignes de `donnees`\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:nbre_lignes) {\n  j <- recup_jt(i)      #\n  n <- recup_n1_n6(i)\n  d <- recup_nd(i)\n  \n  # incrémenter toutes les sorties\n  nums$so[n] <- nums$so[n] + 1\n  dreams$so[d] <- dreams$so[d] + 1\n  \n  # mettre tous les écarts à jour\n  nums$ec <- nums$ec + 1\n  nums$ec[n] <- 0\n  dreams$ec <- dreams$ec + 1\n  dreams$ec[d] <- 0\n  \n  # données du Lundi\n  if(j == \"L\"){\n    # incrémenter les sorties\n    nums$so_L[n] <- nums$so_L[n] + 1\n    dreams$so_L[d] <- dreams$so_L[d] + 1\n    \n    # màj écarts\n    nums$ec_L <- nums$ec_L + 1\n    nums$ec_L[n] <- 0\n    dreams$ec_L <- dreams$ec_L + 1\n    dreams$ec_L[d] <- 0\n  }\n  \n  # données du Jeudi\n  else if(j == \"J\"){\n    # incrémenter les sorties\n    nums$so_J[n] <- nums$so_J[n] + 1\n    dreams$so_J[d] <- dreams$so_J[d] + 1\n    \n     # màj écarts\n    nums$ec_J <- nums$ec_J + 1\n    nums$ec_J[n] <- 0\n    dreams$ec_J <- dreams$ec_J + 1\n    dreams$ec_J[d] <- 0\n    \n  }\n  \n  # Erreur : le jour ne correspond ni à L ni à J\n  #   improbable mais toujours être prudent\n  else{\n    print(\"Erreur de jour (J ou L) ligne \", i,\n          \"de la base de donnée\")\n  }\n  \n}\n```\n:::\n\n\n\n\n\nPour les écarts[@noauthor_espace_2023], c'est « presque » pareil. Tous les écarts sont à $0$ au départ[^eurodreams-1].\n\n[^eurodreams-1]: L'écart d'un numéro est ***toujours*** l'écart par rapport au tirage précédent lors duquel ce numéro est sorti et il n'y avait pas de tirage avant le premier.\n\nOn commence par augmenter ***tous*** les écarts de $1$, puis on met à $0$ les écarts des numéros du tirage examiné.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnums\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 40 × 7\n      nu    so  so_L  so_J    ec  ec_L  ec_J\n   <int> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n 1     1     6     3     3     4     2     6\n 2     2    13     8     5     5     4     2\n 3     3    12     5     7    10     5     7\n 4     4     4     1     3     3    13     1\n 5     5     7     2     5    25    14    12\n 6     6     8     6     2     1     3     0\n 7     7     6     3     3     1     1     0\n 8     8     9     4     5    15     8     7\n 9     9     6     3     3     0     0     5\n10    10     9     4     5     3     6     1\n# ℹ 30 more rows\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(nums)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       nu              so             so_L           so_J            ec        \n Min.   : 1.00   Min.   : 1.00   Min.   : 1.0   Min.   :0.00   Min.   : 0.000  \n 1st Qu.:10.75   1st Qu.: 6.75   1st Qu.: 3.0   1st Qu.:3.00   1st Qu.: 1.000  \n Median :20.50   Median : 9.00   Median : 4.0   Median :4.00   Median : 4.000  \n Mean   :20.50   Mean   : 8.25   Mean   : 4.2   Mean   :4.05   Mean   : 6.325  \n 3rd Qu.:30.25   3rd Qu.:10.00   3rd Qu.: 6.0   3rd Qu.:5.00   3rd Qu.: 9.000  \n Max.   :40.00   Max.   :13.00   Max.   :10.0   Max.   :7.00   Max.   :32.000  \n      ec_L             ec_J     \n Min.   : 0.000   Min.   : 0.0  \n 1st Qu.: 1.000   1st Qu.: 1.0  \n Median : 4.500   Median : 4.0  \n Mean   : 5.925   Mean   : 5.7  \n 3rd Qu.: 8.250   3rd Qu.: 9.0  \n Max.   :22.000   Max.   :27.0  \n```\n\n\n:::\n:::\n\n\n\n\n\n\n### Compter les boules\n\nVu que ces données changent à chaque tirage, il faudrait envisager une autre méthode pour identifier les numéros.\n\nD'un commun accord avec moi-même, j'ai choisi de classer les sorties et les écarts.\n\n$R$ et `dplyr` fournissent de nombreuses fonctions de classement. On va utiliser `min_rank()`.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- tibble(N = c(55, 44, 33, 22, 11, 1, 11, 55, 66))\na <- a |> mutate(CL = min_rank(a$N))\na |> arrange(CL)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 9 × 2\n      N    CL\n  <dbl> <int>\n1     1     1\n2    11     2\n3    11     2\n4    22     4\n5    33     5\n6    44     6\n7    55     7\n8    55     7\n9    66     9\n```\n\n\n:::\n:::\n\n\n\n\n\n$1$ est la plus petite valeur et la plus grande valeur correspond au nombre de valeurs à classer.\n\nCi-dessus, la valeur $1$ est classée première et les deux valeurs $11$ sont classées deuxième. Mais la valeur $22$ est classée quatrième puisqu'il y a deux valeurs classées deuxième. Etc.\n\n\n\nDonc classement.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnumsCL <- tibble(\n  nu = nums$nu,\n  so = min_rank(nums$so),\n  so_L = min_rank(nums$so_L),\n  so_J = min_rank(nums$so_J),\n  ec = min_rank(nums$ec),\n  ec_L = min_rank(nums$ec_L),\n  ec_J = min_rank(nums$ec_J)\n)\n\nnums\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 40 × 7\n      nu    so  so_L  so_J    ec  ec_L  ec_J\n   <int> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n 1     1     6     3     3     4     2     6\n 2     2    13     8     5     5     4     2\n 3     3    12     5     7    10     5     7\n 4     4     4     1     3     3    13     1\n 5     5     7     2     5    25    14    12\n 6     6     8     6     2     1     3     0\n 7     7     6     3     3     1     1     0\n 8     8     9     4     5    15     8     7\n 9     9     6     3     3     0     0     5\n10    10     9     4     5     3     6     1\n# ℹ 30 more rows\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nnumsCL\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 40 × 7\n      nu    so  so_L  so_J    ec  ec_L  ec_J\n   <int> <int> <int> <int> <int> <int> <int>\n 1     1     5     9     6    20    12    26\n 2     2    40    38    23    24    18    13\n 3     3    35    25    39    32    21    27\n 4     4     2     1     6    16    34     7\n 5     5    11     4    23    39    36    36\n 6     6    17    29     2     7    16     1\n 7     7     5     9     6     7     7     1\n 8     8    20    19    23    36    29    27\n 9     9     5     9     6     1     1    22\n10    10    20    19    23    16    23     7\n# ℹ 30 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\nEt pareil pour les numéros `dreams`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndreamsCL <- tibble(\n  nu = dreams$nu,\n  so = min_rank(dreams$so),\n  so_L = min_rank(dreams$so_L),\n  so_J = min_rank(dreams$so_J),\n  ec = min_rank(dreams$ec),\n  ec_L = min_rank(dreams$ec_L),\n  ec_J = min_rank(dreams$ec_J)\n)\n\ndreams\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 7\n     nu    so  so_L  so_J    ec  ec_L  ec_J\n  <int> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n1     1    18     8    10     0     0     0\n2     2     8     3     5     7    11     3\n3     3     8     6     2     2     1     6\n4     4    10     6     4    10     5    11\n5     5    11     5     6     8     4     5\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndreamsCL\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 7\n     nu    so  so_L  so_J    ec  ec_L  ec_J\n  <int> <int> <int> <int> <int> <int> <int>\n1     1     5     5     5     1     1     1\n2     2     1     1     3     3     5     2\n3     3     1     3     1     2     2     4\n4     4     3     3     2     5     4     5\n5     5     4     2     4     4     3     3\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}