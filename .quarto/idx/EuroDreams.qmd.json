{"title":"EuroDreams","markdown":{"yaml":{"author":"Roger MARTIN","date":"last-modified","date-format":"dddd D MMMM YYYY"},"headingText":"EuroDreams","containsRefs":false,"markdown":"\n\n\n## Récupérer l'historique des tirages\n\nLa FDJ met à disposition l'historique des tirages [*Eurodreams*](https://www.fdj.fr/jeux-de-tirage/eurodreams/historique). Et pour analyser des données, il faut des ... données.\n\nIl faut donc commencer par charger les `library()` nécessaires.\n\n```{r}\n#| message: false\n#| warning: false\nlibrary(tidyverse, quietly = TRUE, warn.conflicts = FALSE)\nlibrary(utils)\nlibrary(zip)\n```\n\n```{r}\n#| include: false\n\n# URL du fichiers de données des tirages \n#   sur le site FDJ\n\nurl <- \"https://www.sto.api.fdj.fr/anonymous/service-draw-info/v3/documentations/1a2b3c4d-9876-4562-b3fc-2c963f66afa5\"\n\ndownload.file(url, \"donnees.zip\",  mode = \"wb\")\nunzip(\"donnees.zip\", exdir = \"donnees\", overwrite = TRUE)\n```\n\n```{r}\n#| error: false\n#| message: false\n#| warning: false\n# noms des colonnes à garder\nnoms <- c(\"jour_de_tirage\", \"date_de_tirage\",\n          \"boules_gagnantes_en_ordre_croissant\",\n          \"numero_dream\")\n\ndonnees <- readr::read_csv2(\"donnees/eurodreams_202311.csv\", \n                       col_select = noms)\n# affiche les 6 premières lignes\n#   du tableau `donnees`\nhead(donnees)\n```\n\n```{r}\n# rendre les noms plus accessibles\n\n# le vecteur `noms` contient les noms par paires\n#   \"nonveau nom\" = \"ancien nom\"\nnoms <- c(jt = \"jour_de_tirage\",\n          dt = \"date_de_tirage\",\n          bg = \"boules_gagnantes_en_ordre_croissant\",\n          nd = \"numero_dream\")\ndonnees <- rename(donnees, all_of(noms))\n\n# remplace LUNDI par L et JEUDI par J\ndonnees$jt <- recode(donnees$jt, \"LUNDI\" = \"L\", \"JEUDI\" = \"J\")\nhead(donnees)\n```\n\n```{r}\n# extrait tous les tirages de la \n#   colonne `donnees$bg`\nb <- str_extract_all(donnees$bg, \"\\\\d+\")\n\n# mettre b à plat\nb1 <- unlist(b)\n\n# transforme en nombre\nb1 <- as.integer(b1)\n\n# tranforme la `list()` en `matrix()`\nb2 <- matrix(data = b1, ncol = 6, byrow = TRUE)\n\nhead(b2)\n```\n\n```{r}\n# affecter les colonnes de la matrice au\n#   jeu de données `donnees`\n\ndonnees <- donnees %>% \n  mutate(n1 = b2[,1], .after = bg) %>% \n  mutate(n2 = b2[,2], .after = n1) %>%\n  mutate(n3 = b2[,3], .after = n2) %>% \n  mutate(n4 = b2[,4], .after = n3) %>% \n  mutate(n5 = b2[,5], .after = n4) %>% \n  mutate(n6 = b2[,6], .after = n5) %>% \n  mutate(bg = NULL) \n```\n\n```{r}\n# transforme les jours de tirage `jt` en facteur\ndonnees$jt <- donnees$jt %>%  \n  factor(levels = c(\"L\", \"J\"))\n\n# transforme les dates en dates compréhensibles \n#   par R\ndonnees$dt <- dmy(donnees$dt)\n\n# R sait que `dt` est une colonnes de dates\n#   ranger les tirages en ordre déscendant\n#   ils sont ascendants d'origine\ndonnees <- arrange(donnees, dt)\nhead(donnees)\n```\n\n```{r}\nsummary(donnees)\n```\n\n```{r}\n# Nettoyage\nrm(b, b1, b2, noms, url)\n```\n\n## Stats de base\n\nLes 3 fonctions ci-dessous permettent de récupérer des éléments dans le jeu de données `donnees`.\n\n```{r}\nrecup_n1_n6 <-              # récupère les 6 numéros\n  function(x)               #   du tirage numéro x\n    donnees %>% \n    slice(x) %>% \n    select(n1:n6) %>% \n    as_vector()\n```\n\n```{r}\nrecup_nd <-                 # récupère le numéro dream\n  function(x)               #   du tirage numéro x\n    donnees %>% \n    slice(x) %>% \n    select(nd) %>% \n    as_vector()\n```\n\n```{r}\nrecup_jt <-                 # récupère le jour du tirage\n  function(x)               #   du tirage numéro x\n    donnees %>% \n    slice(x) %>% \n    select(jt) %>% \n    as_vector()\n```\n\nPour gérer les statistiques, on va utiliser des `tibble()` :\n\n```{r}\nnums <- tibble(\n  # Première colonne pour la liste des numéros\n  nu = c(1:40),\n  # Pour les sorties de tous les numéros\n  so = rep.int(0, 40),\n  # Pour les sorties de tous les numéros LUNDI\n  so_L = rep.int(0, 40),\n  # Pour les sorties de tous les numéros JEUDI\n  so_J = rep.int(0, 40),\n  \n  # Pour les écarts de tous les numéros\n  ec = rep.int(0, 40),\n  # Pour les écarts de tous les numéros LUNDI\n  ec_L = rep.int(0, 40),\n  # Pour les écarts de tous les numéros JEUDI\n  ec_J = rep.int(0, 40)\n)\n```\n\net pareil pour les numéros **dream** :\n\n```{r}\ndreams <- tibble(\n  # Première colonne pour la liste des nums dream\n  nu = c(1:5),\n  # Pour les sorties de tous les nums dream\n  so = rep.int(0, 5),\n  # Pour les sorties des nums dream LUNDI\n  so_L = rep.int(0, 5),\n  # Pour les sorties des nums dream JEUDI\n  so_J = rep.int(0, 5),\n  \n  # Pour les écarts de tous les nums dream\n  ec = rep.int(0, 5),\n  # Pour les écarts des nums dream LUNDI\n  ec_L = rep.int(0, 5),\n  # Pour les écarts des nums dream JEUDI\n  ec_J = rep.int(0, 5)\n)\n```\n\n## Premiers calculs\n\nOn va prendre le tiers pour les données initiales.\n\nRemplir les colonnes des `nums` et `dream`. Et commencer à créer des données. Récupérer le nombre de tirages et en retenir $\\frac{1}{3}$.\n\n```{r}\n# nombre de lignes pour commencer\nnbre_lignes <- round(nrow(donnees) / 3)\nnbre_lignes\n```\n\nPuis, itérer[@noauthor_iteration_2025] sur les `nbre_lignes` premières lignes de `donnees`\n\n```{r}\nfor (i in 1:nbre_lignes) {\n  j <- recup_jt(i)      #\n  n <- recup_n1_n6(i)\n  d <- recup_nd(i)\n  \n  # incrémenter toutes les sorties\n  nums$so[n] <- nums$so[n] + 1\n  dreams$so[d] <- dreams$so[d] + 1\n  \n  # mettre tous les écarts à jour\n  nums$ec <- nums$ec + 1\n  nums$ec[n] <- 0\n  dreams$ec <- dreams$ec + 1\n  dreams$ec[d] <- 0\n  \n  # données du Lundi\n  if(j == \"L\"){\n    # incrémenter les sorties\n    nums$so_L[n] <- nums$so_L[n] + 1\n    dreams$so_L[d] <- dreams$so_L[d] + 1\n    \n    # màj écarts\n    nums$ec_L <- nums$ec_L + 1\n    nums$ec_L[n] <- 0\n    dreams$ec_L <- dreams$ec_L + 1\n    dreams$ec_L[d] <- 0\n  }\n  \n  # données du Jeudi\n  else if(j == \"J\"){\n    # incrémenter les sorties\n    nums$so_J[n] <- nums$so_J[n] + 1\n    dreams$so_J[d] <- dreams$so_J[d] + 1\n    \n     # màj écarts\n    nums$ec_J <- nums$ec_J + 1\n    nums$ec_J[n] <- 0\n    dreams$ec_J <- dreams$ec_J + 1\n    dreams$ec_J[d] <- 0\n    \n  }\n  \n  # Erreur : le jour ne correspond ni à L ni à J\n  #   improbable mais toujours être prudent\n  else{\n    print(\"Erreur de jour (J ou L) ligne \", i,\n          \"de la base de donnée\")\n  }\n  \n}\n```\n\nPour les écarts[@noauthor_espace_2023], c'est « presque » pareil. Tous les écarts sont à $0$ au départ[^eurodreams-1].\n\n[^eurodreams-1]: L'écart d'un numéro est ***toujours*** l'écart par rapport au tirage précédent lors duquel ce numéro est sorti et il n'y avait pas de tirage avant le premier.\n\nOn commence par augmenter ***tous*** les écarts de $1$, puis on met à $0$ les écarts des numéros du tirage examiné.\n\n\n```{r}\nnums\n```\n\n```{r}\nsummary(nums)\n```\n\n\n### Compter les boules\n\nVu que ces données changent à chaque tirage, il faudrait envisager une autre méthode pour identifier les numéros.\n\nD'un commun accord avec moi-même, j'ai choisi de classer les sorties et les écarts.\n\n$R$ et `dplyr` fournissent de nombreuses fonctions de classement. On va utiliser `min_rank()`.\n\n```{r}\na <- tibble(N = c(55, 44, 33, 22, 11, 1, 11, 55, 66))\na <- a |> mutate(CL = min_rank(a$N))\na |> arrange(CL)\n```\n\n$1$ est la plus petite valeur et la plus grande valeur correspond au nombre de valeurs à classer.\n\nCi-dessus, la valeur $1$ est classée première et les deux valeurs $11$ sont classées deuxième. Mais la valeur $22$ est classée quatrième puisqu'il y a deux valeurs classées deuxième. Etc.\n\n\n\nDonc classement.\n```{r}\nnumsCL <- tibble(\n  nu = nums$nu,\n  so = min_rank(nums$so),\n  so_L = min_rank(nums$so_L),\n  so_J = min_rank(nums$so_J),\n  ec = min_rank(nums$ec),\n  ec_L = min_rank(nums$ec_L),\n  ec_J = min_rank(nums$ec_J)\n)\n\nnums\n```\n\n```{r}\nnumsCL\n```\n\nEt pareil pour les numéros `dreams`\n```{r}\ndreamsCL <- tibble(\n  nu = dreams$nu,\n  so = min_rank(dreams$so),\n  so_L = min_rank(dreams$so_L),\n  so_J = min_rank(dreams$so_J),\n  ec = min_rank(dreams$ec),\n  ec_L = min_rank(dreams$ec_L),\n  ec_J = min_rank(dreams$ec_J)\n)\n\ndreams\n```\n\n```{r}\ndreamsCL\n```\n\n\n\n\n","srcMarkdownNoYaml":"\n\n# EuroDreams\n\n## Récupérer l'historique des tirages\n\nLa FDJ met à disposition l'historique des tirages [*Eurodreams*](https://www.fdj.fr/jeux-de-tirage/eurodreams/historique). Et pour analyser des données, il faut des ... données.\n\nIl faut donc commencer par charger les `library()` nécessaires.\n\n```{r}\n#| message: false\n#| warning: false\nlibrary(tidyverse, quietly = TRUE, warn.conflicts = FALSE)\nlibrary(utils)\nlibrary(zip)\n```\n\n```{r}\n#| include: false\n\n# URL du fichiers de données des tirages \n#   sur le site FDJ\n\nurl <- \"https://www.sto.api.fdj.fr/anonymous/service-draw-info/v3/documentations/1a2b3c4d-9876-4562-b3fc-2c963f66afa5\"\n\ndownload.file(url, \"donnees.zip\",  mode = \"wb\")\nunzip(\"donnees.zip\", exdir = \"donnees\", overwrite = TRUE)\n```\n\n```{r}\n#| error: false\n#| message: false\n#| warning: false\n# noms des colonnes à garder\nnoms <- c(\"jour_de_tirage\", \"date_de_tirage\",\n          \"boules_gagnantes_en_ordre_croissant\",\n          \"numero_dream\")\n\ndonnees <- readr::read_csv2(\"donnees/eurodreams_202311.csv\", \n                       col_select = noms)\n# affiche les 6 premières lignes\n#   du tableau `donnees`\nhead(donnees)\n```\n\n```{r}\n# rendre les noms plus accessibles\n\n# le vecteur `noms` contient les noms par paires\n#   \"nonveau nom\" = \"ancien nom\"\nnoms <- c(jt = \"jour_de_tirage\",\n          dt = \"date_de_tirage\",\n          bg = \"boules_gagnantes_en_ordre_croissant\",\n          nd = \"numero_dream\")\ndonnees <- rename(donnees, all_of(noms))\n\n# remplace LUNDI par L et JEUDI par J\ndonnees$jt <- recode(donnees$jt, \"LUNDI\" = \"L\", \"JEUDI\" = \"J\")\nhead(donnees)\n```\n\n```{r}\n# extrait tous les tirages de la \n#   colonne `donnees$bg`\nb <- str_extract_all(donnees$bg, \"\\\\d+\")\n\n# mettre b à plat\nb1 <- unlist(b)\n\n# transforme en nombre\nb1 <- as.integer(b1)\n\n# tranforme la `list()` en `matrix()`\nb2 <- matrix(data = b1, ncol = 6, byrow = TRUE)\n\nhead(b2)\n```\n\n```{r}\n# affecter les colonnes de la matrice au\n#   jeu de données `donnees`\n\ndonnees <- donnees %>% \n  mutate(n1 = b2[,1], .after = bg) %>% \n  mutate(n2 = b2[,2], .after = n1) %>%\n  mutate(n3 = b2[,3], .after = n2) %>% \n  mutate(n4 = b2[,4], .after = n3) %>% \n  mutate(n5 = b2[,5], .after = n4) %>% \n  mutate(n6 = b2[,6], .after = n5) %>% \n  mutate(bg = NULL) \n```\n\n```{r}\n# transforme les jours de tirage `jt` en facteur\ndonnees$jt <- donnees$jt %>%  \n  factor(levels = c(\"L\", \"J\"))\n\n# transforme les dates en dates compréhensibles \n#   par R\ndonnees$dt <- dmy(donnees$dt)\n\n# R sait que `dt` est une colonnes de dates\n#   ranger les tirages en ordre déscendant\n#   ils sont ascendants d'origine\ndonnees <- arrange(donnees, dt)\nhead(donnees)\n```\n\n```{r}\nsummary(donnees)\n```\n\n```{r}\n# Nettoyage\nrm(b, b1, b2, noms, url)\n```\n\n## Stats de base\n\nLes 3 fonctions ci-dessous permettent de récupérer des éléments dans le jeu de données `donnees`.\n\n```{r}\nrecup_n1_n6 <-              # récupère les 6 numéros\n  function(x)               #   du tirage numéro x\n    donnees %>% \n    slice(x) %>% \n    select(n1:n6) %>% \n    as_vector()\n```\n\n```{r}\nrecup_nd <-                 # récupère le numéro dream\n  function(x)               #   du tirage numéro x\n    donnees %>% \n    slice(x) %>% \n    select(nd) %>% \n    as_vector()\n```\n\n```{r}\nrecup_jt <-                 # récupère le jour du tirage\n  function(x)               #   du tirage numéro x\n    donnees %>% \n    slice(x) %>% \n    select(jt) %>% \n    as_vector()\n```\n\nPour gérer les statistiques, on va utiliser des `tibble()` :\n\n```{r}\nnums <- tibble(\n  # Première colonne pour la liste des numéros\n  nu = c(1:40),\n  # Pour les sorties de tous les numéros\n  so = rep.int(0, 40),\n  # Pour les sorties de tous les numéros LUNDI\n  so_L = rep.int(0, 40),\n  # Pour les sorties de tous les numéros JEUDI\n  so_J = rep.int(0, 40),\n  \n  # Pour les écarts de tous les numéros\n  ec = rep.int(0, 40),\n  # Pour les écarts de tous les numéros LUNDI\n  ec_L = rep.int(0, 40),\n  # Pour les écarts de tous les numéros JEUDI\n  ec_J = rep.int(0, 40)\n)\n```\n\net pareil pour les numéros **dream** :\n\n```{r}\ndreams <- tibble(\n  # Première colonne pour la liste des nums dream\n  nu = c(1:5),\n  # Pour les sorties de tous les nums dream\n  so = rep.int(0, 5),\n  # Pour les sorties des nums dream LUNDI\n  so_L = rep.int(0, 5),\n  # Pour les sorties des nums dream JEUDI\n  so_J = rep.int(0, 5),\n  \n  # Pour les écarts de tous les nums dream\n  ec = rep.int(0, 5),\n  # Pour les écarts des nums dream LUNDI\n  ec_L = rep.int(0, 5),\n  # Pour les écarts des nums dream JEUDI\n  ec_J = rep.int(0, 5)\n)\n```\n\n## Premiers calculs\n\nOn va prendre le tiers pour les données initiales.\n\nRemplir les colonnes des `nums` et `dream`. Et commencer à créer des données. Récupérer le nombre de tirages et en retenir $\\frac{1}{3}$.\n\n```{r}\n# nombre de lignes pour commencer\nnbre_lignes <- round(nrow(donnees) / 3)\nnbre_lignes\n```\n\nPuis, itérer[@noauthor_iteration_2025] sur les `nbre_lignes` premières lignes de `donnees`\n\n```{r}\nfor (i in 1:nbre_lignes) {\n  j <- recup_jt(i)      #\n  n <- recup_n1_n6(i)\n  d <- recup_nd(i)\n  \n  # incrémenter toutes les sorties\n  nums$so[n] <- nums$so[n] + 1\n  dreams$so[d] <- dreams$so[d] + 1\n  \n  # mettre tous les écarts à jour\n  nums$ec <- nums$ec + 1\n  nums$ec[n] <- 0\n  dreams$ec <- dreams$ec + 1\n  dreams$ec[d] <- 0\n  \n  # données du Lundi\n  if(j == \"L\"){\n    # incrémenter les sorties\n    nums$so_L[n] <- nums$so_L[n] + 1\n    dreams$so_L[d] <- dreams$so_L[d] + 1\n    \n    # màj écarts\n    nums$ec_L <- nums$ec_L + 1\n    nums$ec_L[n] <- 0\n    dreams$ec_L <- dreams$ec_L + 1\n    dreams$ec_L[d] <- 0\n  }\n  \n  # données du Jeudi\n  else if(j == \"J\"){\n    # incrémenter les sorties\n    nums$so_J[n] <- nums$so_J[n] + 1\n    dreams$so_J[d] <- dreams$so_J[d] + 1\n    \n     # màj écarts\n    nums$ec_J <- nums$ec_J + 1\n    nums$ec_J[n] <- 0\n    dreams$ec_J <- dreams$ec_J + 1\n    dreams$ec_J[d] <- 0\n    \n  }\n  \n  # Erreur : le jour ne correspond ni à L ni à J\n  #   improbable mais toujours être prudent\n  else{\n    print(\"Erreur de jour (J ou L) ligne \", i,\n          \"de la base de donnée\")\n  }\n  \n}\n```\n\nPour les écarts[@noauthor_espace_2023], c'est « presque » pareil. Tous les écarts sont à $0$ au départ[^eurodreams-1].\n\n[^eurodreams-1]: L'écart d'un numéro est ***toujours*** l'écart par rapport au tirage précédent lors duquel ce numéro est sorti et il n'y avait pas de tirage avant le premier.\n\nOn commence par augmenter ***tous*** les écarts de $1$, puis on met à $0$ les écarts des numéros du tirage examiné.\n\n\n```{r}\nnums\n```\n\n```{r}\nsummary(nums)\n```\n\n\n### Compter les boules\n\nVu que ces données changent à chaque tirage, il faudrait envisager une autre méthode pour identifier les numéros.\n\nD'un commun accord avec moi-même, j'ai choisi de classer les sorties et les écarts.\n\n$R$ et `dplyr` fournissent de nombreuses fonctions de classement. On va utiliser `min_rank()`.\n\n```{r}\na <- tibble(N = c(55, 44, 33, 22, 11, 1, 11, 55, 66))\na <- a |> mutate(CL = min_rank(a$N))\na |> arrange(CL)\n```\n\n$1$ est la plus petite valeur et la plus grande valeur correspond au nombre de valeurs à classer.\n\nCi-dessus, la valeur $1$ est classée première et les deux valeurs $11$ sont classées deuxième. Mais la valeur $22$ est classée quatrième puisqu'il y a deux valeurs classées deuxième. Etc.\n\n\n\nDonc classement.\n```{r}\nnumsCL <- tibble(\n  nu = nums$nu,\n  so = min_rank(nums$so),\n  so_L = min_rank(nums$so_L),\n  so_J = min_rank(nums$so_J),\n  ec = min_rank(nums$ec),\n  ec_L = min_rank(nums$ec_L),\n  ec_J = min_rank(nums$ec_J)\n)\n\nnums\n```\n\n```{r}\nnumsCL\n```\n\nEt pareil pour les numéros `dreams`\n```{r}\ndreamsCL <- tibble(\n  nu = dreams$nu,\n  so = min_rank(dreams$so),\n  so_L = min_rank(dreams$so_L),\n  so_J = min_rank(dreams$so_J),\n  ec = min_rank(dreams$ec),\n  ec_L = min_rank(dreams$ec_L),\n  ec_J = min_rank(dreams$ec_J)\n)\n\ndreams\n```\n\n```{r}\ndreamsCL\n```\n\n\n\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","reference-location":"margin","toc":true,"output-file":"EuroDreams.html"},"language":{"toc-title-document":"Table des matières","toc-title-website":"Sur cette page","related-formats-title":"Autres formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"La source","other-links-title":"Autres liens","code-links-title":"Liens de code","launch-dev-container-title":"Lancer le Dev Container","launch-binder-title":"Lancer le Binder","article-notebook-label":"Cahier d'articles","notebook-preview-download":"Télécharger le cahier","notebook-preview-download-src":"Télécharger le code source","notebook-preview-back":"Retour à l'article","manuscript-meca-bundle":"Archive MECA","section-title-abstract":"Résumé","section-title-appendices":"Annexes","section-title-footnotes":"Notes de bas de page","section-title-references":"Les références","section-title-reuse":"Réutilisation","section-title-copyright":"Droits d'auteur","section-title-citation":"Citation","appendix-attribution-cite-as":"Veuillez citer ce travail comme suit :","appendix-attribution-bibtex":"BibTeX","appendix-view-license":"Voir la Licence","title-block-author-single":"Auteur·rice","title-block-author-plural":"Auteur·rice·s","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Date de publication","title-block-modified":"Modifié","title-block-keywords":"Mots clés","callout-tip-title":"Astuce","callout-note-title":"Note","callout-warning-title":"Avertissement","callout-important-title":"Important","callout-caution-title":"Mise en garde","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Montrer tout le code","code-tools-hide-all-code":"Cacher tout le code","code-tools-view-source":"Voir les sources","code-tools-source-code":"Code source","tools-share":"Share","tools-download":"Download","code-line":"Ligne","code-lines":"Lignes","copy-button-tooltip":"Copier vers le presse-papier","copy-button-tooltip-success":"Copié","repo-action-links-edit":"Modifier cette page","repo-action-links-source":"Voir la source","repo-action-links-issue":"Faire part d'un problème","back-to-top":"Retour au sommet","search-no-results-text":"Pas de résultats","search-matching-documents-text":"documents trouvés","search-copy-link-title":"Copier le lien vers la recherche","search-hide-matches-text":"Cacher les correspondances additionnelles","search-more-match-text":"correspondance de plus dans ce document","search-more-matches-text":"correspondances de plus dans ce document","search-clear-button-title":"Effacer","search-text-placeholder":"","search-detached-cancel-button-title":"Annuler","search-submit-button-title":"Envoyer","search-label":"Recherche","toggle-section":"Basculer la section","toggle-sidebar":"Basculer la barre latérale","toggle-dark-mode":"Basculer le mode sombre","toggle-reader-mode":"Basculer en mode lecteur","toggle-navigation":"Basculer la navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Théorème","crossref-lem-title":"Lemme","crossref-cor-title":"Corollaire","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Définition","crossref-exm-title":"Exemple","crossref-exr-title":"Exercice","crossref-ch-prefix":"Chapitre","crossref-apx-prefix":"Annexe","crossref-sec-prefix":"Section","crossref-eq-prefix":"Équation","crossref-lof-title":"Liste des Figures","crossref-lot-title":"Liste des Tables","crossref-lol-title":"Liste des Listings","environment-proof-title":"Preuve","environment-remark-title":"Remarque","environment-solution-title":"Solution","listing-page-order-by":"Trier par","listing-page-order-by-default":"Ordre par défaut","listing-page-order-by-date-asc":"Le plus ancien","listing-page-order-by-date-desc":"Le plus récent","listing-page-order-by-number-desc":"Descendant","listing-page-order-by-number-asc":"Ascendant","listing-page-field-date":"Date","listing-page-field-title":"Titre","listing-page-field-description":"Description","listing-page-field-author":"Auteur·rice","listing-page-field-filename":"Nom de fichier","listing-page-field-filemodified":"Modifié","listing-page-field-subtitle":"Sous-titre","listing-page-field-readingtime":"Temps de lecture","listing-page-field-wordcount":"Compteur de Mots","listing-page-field-categories":"Catégories","listing-page-minutes-compact":"{0} min.","listing-page-category-all":"Tous","listing-page-no-matches":"Aucun article correspondant","listing-page-words":"{0} mots","listing-page-filter":"Filtre","draft":"Brouillon"},"metadata":{"lang":"fr-FR","fig-responsive":true,"quarto-version":"1.6.43","fontsize":"1.20em","cap-location":"margin","citation-location":"margin","bibliography":["references.bib"],"mermaid":{"theme":"neutral"},"theme":{"dark":["darkly","theme-dark.scss"],"light":["flatly","theme-light.scss"]},"grid":{"margin-width":"225px","sidebar-width":"225px","body-width":"999px","gutter-width":"0.5rem"},"author":"Roger MARTIN","date":"last-modified","date-format":"dddd D MMMM YYYY"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}